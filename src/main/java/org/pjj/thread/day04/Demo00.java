package org.pjj.thread.day04;

/**
 * 线程通信
 *
 * 应用场景: 生产者消费者模式
 *      * 假设仓库中只能存放一件产品, 生产者将生产出来的商品放入仓库, 消费者将仓库中的产品取走消费
 *      * 如果仓库中没有产品, 则生产者将产品放入仓库, 否则停止生产并等待, 直到仓库中的产品被消费者取走为止
 *      * 如果仓库中放有产品, 则消费者可以将产品取走消费, 否则停止消费并等待, 直到仓库中再次放入产品为止
 *
 * 分析: 这是一个线程同步问题, 生产者和消费者共享同一个资源, 并且生产者和消费者之前相互依赖, 互为条件
 *      * 对于生产者, 没有生产产品之前, 要通知消费者等待, 而生产了产品之后, 又需要马上通知消费者消费
 *      * 对于消费者, 在消费之后, 要通知生产者已经消费结束, 需要继续生产新产品以供消费
 *      * 在生产者消费者问题中, 仅有synchronized是不够的
 *              * synchronized可阻止并发更新同一个共享资源, 实现了同步
 *              * synchronized不能用来实现不同线程之前的消息传递(通信)
 *
 * 解决方式1: 并发协作模型 "生产者/消费者模式" => 管程法
 * 解决方式2: 并发协作模型 "生产者/消费者模式" => 信号灯法
 *
 * Java提供了 3个方法解决线程之间的通信问题
 * final void wait(); //表示线程一直等待, 直到其他线程通知, 与 sleep不同, 会释放锁
 * final void wait(long timeout); //指定等待的毫秒数
 * final void notify(); //唤醒一个处于等待状态的线程
 * final void notifyAll(); //唤醒一个对象上所有调度wait()方法的线程, 优先级别高的线程优先调度
 * 注意: 均是java.lang.Object类的方法, 都只能在同步方法 或 同步块中使用, 否则会抛出异常
 *
 * @author PengJiaJun
 * @Date 2022/08/15 17:50
 */
public class Demo00 {
}
