package org.pjj.thread.day06;

/**
 * 测试 锁数组中的某个元素, 其他元素能不能正常访问
 *
 * 打印结果为:
 * 线程零.....
 * 线程零.....
 * 线程零.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程零.....
 * 线程二.....
 * 线程一.....
 * 线程二.....
 * 线程一.....
 * 线程二.....
 * 线程一.....
 * 线程二.....
 * 线程一.....
 * 线程一.....
 * 线程一.....
 * 线程一.....
 * 线程一.....
 * 线程一.....
 * 线程一.....
 *
 * 从打印结果来看, 线程零锁住了 integers[0] 所以在线程零执行期间, 线程一不可能执行因为线程一也是需要获取 integers[0]的锁,
 * 而 线程二 确实可以在 线程零执行期间执行, 说明线程零锁的 integers[0], 不影响线程二 获取 integers[2] 的锁
 *
 *
 * @author PengJiaJun
 * @Date 2022/08/23 22:09
 */
public class TestSynchronized02 {
    public static void main(String[] args) throws InterruptedException {
        Integer[] integers = new Integer[]{new Integer(0), new Integer(1), new Integer(2)};

        new Thread(() -> {
            Integer index0 = integers[0];
            synchronized (index0) {
                for (int i = 0; i < 10; i++) {
                    System.out.println("线程零.....");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

        Thread.sleep(2000);


        new Thread(() -> {
            Integer index0 = integers[0];
            synchronized (index0) {
                for (int i = 0; i < 10; i++) {
                    System.out.println("线程一.....");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

        Thread.sleep(2000);

        new Thread(() -> {
            Integer index2 = integers[2];
            synchronized (index2) {
                for (int i = 0; i < 10; i++) {
                    System.out.println("线程二.....");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

    }
}
